## 1 - 异常（重点）

### 1.1 - 基本概念

​	异常，指不正常，在Java中异常处理机制能让程序在异常情况发生时，按照预先设定的异常处理逻辑去有针对性的处理异常的情况。

java.lang.Throwable类是Java中所有错误或异常的超类，已知直接子类有Error类和Exception类。

![异常](C:\Users\HP\Desktop\java\异常.png)

### 1.2 - 异常的主要分类

java.lang.Exception类是所有异常类的超类。

| 名称             | 说明                             |
| ---------------- | -------------------------------- |
| RuntimeException | 运行时异常类，也叫作非检测性异常 |
| IOException      | IO异常类，也叫作检测性异常       |

#### **RuntimeException类的主要子类**

| 异常类型                       | 说明                         |
| ------------------------------ | ---------------------------- |
| ArithmeticExceptoi算数异常     | 算数异常                     |
| ArrayIndexOutofBoundsException | 数组下标越界异常（间接子类） |
| NullPointerException           | 空指针异常                   |
| ClassCastException             | 类型转换异常                 |
| NumberFormatException          | 数字格式异常（间接子类）     |



```java
/**
 * @author ly_smith
 * @Description #TODO   RuntimeException的情况
 */
public class Demo01 {
    public static void main(String[] args) {
//        ArithmeticException   算数异常
        int a = 10;
        int b = 0;
        if(b != 0){
            System.out.println(a/b);
        }
        /*try {
            System.out.println(a/b);
        }catch (ArithmeticException e){
            System.out.println("0不能作为除数！");
        }*/
//        ArrayIndexOutOfBoundsException   数组下标越界异常
        int[] arr = new int[5];
        int pos = 5;
        if(pos < 5 && pos >= 0){
            System.out.println(arr[pos]);
        }
//        NullPointerException   空指针异常
        String s1 = null;
        if (s1 != null){
             System.out.println(s1.length());
        }
//        ClassCastException    类型转换异常
        Exception e = new Exception();
        if(e instanceof IOException){  //instanceof用来判断e 是否属于IOException类型的引用
            IOException io = (IOException) e;
        }
//        NumberFormatException   数字格式异常
        String s2 = "123abc";
        if(s2.matches("\\d+")){ //matches判断字符串规则，正则表达式
            System.out.println(Integer.parseInt(s2));
        }
    }
}

```

**运行时异常的处理**

​	绝大多数的运行时异常都可以采用if判断的方式避免掉

### 1.3 - 异常的捕获格式

```java
try{
    编写可能产生异常的语句
}catch(异常类型 变量名){
    编写针对该异常的处理语句
}finally{
    编写无论是否发生异常都会执行的语句块
}
```

### 1.4 - 异常的执行流程

```java
/**
 * @author ly_smith
 * @Description #TODO  异常的执行流程
 */
public class Demo02 {
    public static void main(String[] args) {
        try {
            System.out.println("a");
            FileInputStream fis = new FileInputStream("./a.txt");//检测性异常
            System.out.println("b");
        } catch (FileNotFoundException e) {
            System.out.println("c");
            e.printStackTrace();
        }finally {  //不管异常是否出现，都执行的语句块
            System.out.println("d");
        }
        System.out.println("e");
        //当异常发生的时候的执行流程：a c d e
        //当异常没有发生的时候的执行流程：a b d e
    }
}
```

当异常发生的时候的执行流程：a c d e
当异常没有发生的时候的执行流程：a b d e

#### 注意事项

​		当需要多个catch的情况，切记小类型需要放在大类型的上面

```java
/**
 * @author ly_smith
 * @Description #TODO   当多个catch同时出现时
 */
public class Demo03 {
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("./a.txt");
        } catch (FileNotFoundException e) {  //儿子类
            e.printStackTrace();
        }catch (IOException e) { //父亲类
            e.printStackTrace();
        }catch (Exception e) {//爷爷类
            e.printStackTrace();
        }
//        当需要多个catch的情况，切记小类型需要放在大类型的上面
    }
}
```

### 1.5 - 手动抛出异常

概念：

​	在某种特殊的场合中，对于出现的异常无法直接处理或者不方便处理的时候，可以选择将该异常转移给方法的调用者，这种形式叫做异常的抛出。

```java
/**
 * @author ly_smith
 * @Description #TODO   异常的抛出
 */
public class Demo04 {
    //异常的抛出   ,当抛出多个异常类的时候，小类型需要放在前面
    public static void show() throws FileNotFoundException,IOException,Exception {
        FileInputStream fis = new FileInputStream("./a.txt");
    }

    public static void main(String[] args){
        //一般情况下异常抛到主方法时，进行捕获
        try {
            Demo04.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

语法格式

```java
//返回值类型 方法名（形参） throws 异常类型（小），异常类型（中）,异常类型（大） 
public static void show() throws FileNotFoundException,IOException,Exception {}
```

#### 注意事项：

当子类中重写父类的方法时，可以抛出一样的异常，可以抛出更小的异常，但是不能抛更大的异常

```java
/**
 * @author ly_smith
 * @Description #TODO  父类方法抛出异常
 */
public class Demo05 {
    //父类中的方法抛出IOException
    public void show() throws IOException {
        System.out.println("123");
    }
}
/**
 * @author ly_smith
 * @Description #TODO  子类重写父类的方法时，异常的处理
 */
public class Demo06 extends Demo05{

    /*@Override //子类重写父类中的方法时，可以抛出相同的异常
    public void show() throws IOException {
        super.show();
    }*/
    /*@Override //子类可以抛出比父类更小的异常
    public void show() throws FileNotFoundException {
        try {
            super.show();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }*/
    /*@Override  //子类不可以抛出比父类更大的异常
    public void show() throws Exception {
        super.show();
    }*/
}
```

### 1.6 - 自定义异常类

方法：

​		自定义异常类需要继承Exception类或者其子类，一共两个版本的构造方法，一个有参，一个无参。

```java
/**
 * @author ly_smith
 * @Description #TODO  自定义年龄异常类
 */
public class AgeException extends Exception{
    public AgeException() {
    }

    public AgeException(String message) {//接收异常抛出时提示的信息
        super(message);//将异常提示信息传递到父类中
    }
}
//Student实体类中setAge方法
public void setAge(int age) throws AgeException {
        if (age >= 0 && age < 120){
            this.age = age;
        }else {
            throw new AgeException("您输入的年龄不合理！");
//            System.out.println("您输入的年龄不合理！");
        }
    
/**
 * @author ly_smith
 * @Description #TODO  自定义异常的测试类
 */
public class AgeExceptionTest {
    public static void main(String[] args) {
        try {
            Student stu = new Student("洋哥", -18);
        } catch (AgeException e) {
            e.printStackTrace();
        }

    }
}    
```

课后任务

1、自定义异常类AgeException和NameException，年龄范围（0 - 120），姓名长度（2-4）个字，如果不合理，则抛出异常。一对try catch只能捕获一个异常。









